//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŒ€  MACRO: TRASLADAR ÃTEMS ENTRE CONTENEDORES
// ðŸ“…  VersiÃ³n : 3.2 Â· 23-May-2025
// âœï¸  Autor   : Voorhees
// ðŸ—ºï¸  Servidor: Ãšltima Alianza
// ðŸ’»  Cliente : ClassicUO Web
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ“–  INSTRUCCIONES RÃPIDAS  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Si algÃºn valor de CONFIG es 0, aparecerÃ¡n tres cursores para seÃ±alar:
//        1ï¸âƒ£  Contenedor ORIGEN
//        2ï¸âƒ£  Contenedor DESTINO  (puede estar dentro del ORIGEN)
//        3ï¸âƒ£  OBJETO EJEMPLO      (una pieza del tipo a mover)
// 2. El script crea una lista fija de todos los Ã­tems del mismo *graphic*
//    encontrados en ORIGEN (y sub-contenedores si `recursive = true`), EXCLUYENDO
//    los que ya estÃ©n en el Ã¡rbol del DESTINO.  Esa lista se recorre una sola
//    vez, por lo que los objetos depositados no vuelven a procesarse.
// 3. Cada traslado usa `player.moveItem()` y espera `moveDelayMs` ms.
// 4. Mensajes solo para ti (hue 66) en el chat del sistema.
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


/*â•â•â•â•â•â•â•â•â•â•â•â• âš™ï¸  CONFIGURACIÃ“N  â•â•â•â•â•â•â•â•â•â•â•â•*/
const CFG = {
  sourceSerial : 0,      // ORIGEN   (0 = pedir)
  destSerial   : 0,      // DESTINO  (0 = pedir)
  itemGraphic  : 0,      // Graphic del Ã­tem (0 = pedir)
  recursive    : true,   // true = busca en sub-contenedores
  moveDelayMs  : 600,    // Pausa entre movimientos
  maxToMove    : 0       // 0 = sin lÃ­mite; >0 = mÃ¡ximo a trasladar
};


/*â•â•â•â•â•â•â•â•â•â•â•â• ðŸ› ï¸  UTILIDADES  â•â•â•â•â•â•â•â•â•â•â•â•*/
const say = (txt: string, hue = 66) => client.sysMsg(txt, hue);

/** Pide un target interactivo si el campo vale 0. */
function request<K extends keyof typeof CFG>(
  key: K, prompt: string, pick: (ti: TargetInfo) => number)
{
  if (CFG[key]) return;
  say(`ðŸ“Œ ${prompt} â€” haz clic`, 34);
  const ti = target.query();                 // cursor de selecciÃ³n
  if (!ti) exit(`Cancelado: ${prompt}`);
  CFG[key] = pick(ti) as any;
  say(`${key} = 0x${(+CFG[key]).toString(16)}`, 88);
}

/** TRUE si Â«childÂ» estÃ¡ (a cualquier nivel) dentro de Â«ancestorÂ». */
function inside(child: number, ancestor: number): boolean {
  for (let cur = child; cur; ) {
    if (cur === ancestor) return true;
    const o = client.findObject(cur) as Item | undefined;
    if (!o) break;
    cur = o.containerSerial;
  }
  return false;
}


/*â•â•â•â•â•â•â•â•â•â•â•â• ðŸš€  EJECUCIÃ“N  â•â•â•â•â•â•â•â•â•â•â•â•*/
(()=>{
  /*â”€â”€ 1. Selecciones â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
  request('sourceSerial','Contenedor ORIGEN',  ti => ti.serial);
  request('destSerial',  'Contenedor DESTINO', ti => ti.serial);
  request('itemGraphic', 'Objeto EJEMPLO',     ti => ti.graphic);

  /*â”€â”€ 2. Lista fija de trabajo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
  say('ðŸ”Ž Compilando lista de Ã­temsâ€¦', 66);

  const depth = CFG.recursive ? undefined : 0;          // undefined = profundo
  let items = client.findAllItemsOfType(
                 CFG.itemGraphic,
                 undefined,
                 CFG.sourceSerial,
                 undefined,
                 depth) as Item[];

  // Excluye cualquier Ã­tem que ya estÃ© en la rama del DESTINO
  items = items.filter(it => !inside(it.serial, CFG.destSerial));

  if (items.length === 0){
    say('âŒ No se encontrÃ³ ningÃºn Ã­tem para mover.', 33); return;
  }
  if (CFG.maxToMove && CFG.maxToMove > 0)
      items = items.slice(0, CFG.maxToMove);

  /*â”€â”€ 3. Traslado secuencial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
  let moved = 0;
  for (const it of items){
    player.moveItem(it.serial, CFG.destSerial);   // API oficial para mover
    moved++;
    sleep(CFG.moveDelayMs);
  }

  say(`âœ… Traslado completo: ${moved} objeto(s).`, 65);
})();

