/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ“  MACRO: DESLOTEAR â€œBUNDLESâ€ DE PERGAMINOS
 ğŸ“…  VersiÃ³n 1.2 Â· 24-May-2025
 âœï¸  Autor   : Voorhees
 ğŸ—ºï¸  Servidor: Ãšltima Alianza   Â·   ğŸ’» Cliente: ClassicUO Web

 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ“–  RESUMEN  ğŸ“– â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 â€¢ Selecciona 3 cursores:  
     1ï¸âƒ£ Cofre con **lotes** (bundles) ğŸ“¦  
     2ï¸âƒ£ Un **bundle de ejemplo** ğŸ (sirve solo para leer el *graphic*)  
     3ï¸âƒ£ Cofre de **salida** (donde caerÃ¡n los 4 blanks)  
 â€¢ La macro mueve **exactamente 1 bundle** por ciclo:  
     mover â†’ doble-click â†’ aparecen 4 pergaminos en blanco â†’ los devuelve  
   al cofre. Repite hasta que no queda ningÃºn bundle (graphic 0x1F14).  
 â€¢ No filtra por *hue*: procesa cualquier lote del mismo graphic, asÃ­ los  
   â€œmarronesâ€ o tintados tambiÃ©n se abren.  
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

/*â•â•â•â•â•â•â•â•â•â•â•â• âš™ï¸  CONFIGURACIÃ“N â•â•â•â•â•â•â•â•â•â•â•â•*/
const CFG = {
  sourceSerial   : 0,        // Cofre con bundles (0 = pedir)
  bundleGraphic  : 0,        // Graphic del bundle   (0 = pedir)
  destSerial     : 0,        // Cofre de salida      (0 = pedir)

  blankGraphic   : 0x0E34,   // ğŸ“„ Pergamino en blanco
  blankHue       : 0x0000,   // Hue 0 = blanco real

  moveDelayMs    : 1200,
  openDelayMs    : 600,
};

/*â•â•â•â•â•â•â•â•â•â•â•â• ğŸ› ï¸  UTILIDADES  â•â•â•â•â•â•â•â•â•â•â•â•â•*/
const say = (t:string,h=66)=>client.sysMsg(t,h);

/*â”€â”€ 1. CAPTURA DE OBJETIVOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function pick(label:string,set:(ti:TargetInfo)=>void){
  say(`ğŸ“Œ ${label} â€“ haz clic`,34);
  const ti=target.query(); if(!ti) exit('Cancelado');
  set(ti); say(`${label} OK`,88);
}
if(!CFG.sourceSerial)  pick('Cofre con LOTES',  ti=>CFG.sourceSerial=ti.serial);
if(!CFG.bundleGraphic) pick('Bundle de EJEMPLO',ti=>CFG.bundleGraphic=ti.graphic);
if(!CFG.destSerial)    pick('Cofre de SALIDA',  ti=>CFG.destSerial=ti.serial);

/*â”€â”€ 2. FUNCIONES DE APOYO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
const nextBundle = ()=> client.findType(
  CFG.bundleGraphic, undefined, CFG.sourceSerial, undefined, 0) as Item|undefined;

const blanksInBag = ()=> client.findAllItemsOfType(
  CFG.blankGraphic, CFG.blankHue, player.backpack, undefined, 0) as Item[];

/*â•â•â•â•â•â•â•â•â•â•â•â• ğŸš€ BUCLE PRINCIPAL â•â•â•â•â•â•â•â•â•â•â•â•*/
say('âœ… Desloteo iniciadoâ€¦',65);

while(true){
  const bun = nextBundle();
  if(!bun){ say('âœ”ï¸ No quedan lotes. Macro OFF.',65); break; }

  /* 1) Mover **1** unidad del bundle al backpack */
  player.moveItem(bun.serial, player.backpack.serial, 0,0,0, 1);
  const t0 = Date.now();
  let bunBag: Item|undefined;
  /* Espera hasta 2 s a que aparezca en la mochila */
  do{
    bunBag = client.findType(
              CFG.bundleGraphic, CFG.bundleHue, player.backpack) as Item;
    if(bunBag) break;
    sleep(100);
  }while(Date.now()-t0 < 2000);

  if(!bunBag){ say('âš ï¸ Lote no llegÃ³ a la mochila (timeout). ContinÃºoâ€¦',33); continue; }

  /* 2) Abrir el bundle */
  player.use(bunBag);  sleep(CFG.openDelayMs);

  /* 3) Devolver los blanks producidos */
  for(const s of blanksInBag())
    player.moveItem(s.serial, CFG.destSerial);

  sleep(CFG.moveDelayMs);
}
